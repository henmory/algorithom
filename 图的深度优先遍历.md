# 一、图的存储方式
  
  图有好几种存储方式，今天主要谈无向图的邻接矩阵存储方式（而且图是联通的）
  
## 1.邻接矩阵
  
  邻接矩阵就是用一个数组代表图的顶点，一个邻接矩阵代表顶点与顶点之间的链接，1为有链接，0为没有链接

# 二、深度优先遍历思想
  
  深度优先遍历是，找随便一个顶点作为起点，按照一定的规则（不能变），查找下一个顶点，如果该顶点没有遍历，继续寻找该顶点的下一个邻接顶点，
  
  直到找到的顶点都已访问或者没有下一个顶点时，按照刚才的遍历方式倒退，一直退到顶点位置
  

# 三、图的深度优先遍历算法
  
  由于github对图片支持的不是特别好，进而这里就不上传图片说明了。
  
  1.假设顶点都存在数组a中，通过a.lenght可计算顶点个数
  
  2.所有边的情况都存在邻接矩阵b中，b的每一行代表一个顶点，与其他顶点是否相连，1相连，0不相连
  
  3.假设我们从第一行的顶点V0作为起点，开始搜索，遍历算法如下
  
  4.首先查看第一行中第一个1，进而可以得知V0与哪个顶点相交
  
  5.如果这个顶点没有被访问过，（需要定义一个数组来记录顶点是否被访问过）那么访问这个顶点，即扫码这个顶点所在行的1的情况
  
  6.然后按照4-5步开始遍历该节点的下一个节点
  
  7.当该节点没有找到可以访问的下一个节点时，此时要退回它的上一个顶点的访问位置，继续遍历上一个顶点的剩余行中是否还有1
  
  8.如果有 按照 4-5步继续访问，如果没有退到该节点的上一个顶点，以此类推，最后回到起始点，遍历结束
  
# 四、代码介绍

  对于无向连通图来说，行列数是一样的，不用单独的数组表示顶点都可以，因为每一行就代表一个顶点
 
  int[][] a===>存有所有边的邻接矩阵
  
  rows = a.length===>行数
  
  columns ＝ a[0].length===>列数
  
  int[] visit===>代表顶点是否被访问过
  
  void DFS(int j){

    for(int j = 0; j < columns; j++){

      visit[j] = true;

      if(false == visit[j] && a[i][j] == 1){ ===>代表新找到的元素没有被访问过，且它与上一个元素有连接

          DFS(j);

      }

    }

  }
  
  

